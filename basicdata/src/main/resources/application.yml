server:
  port: 15200
spring:
  application:
    name: cloud-basicdata-chendeyin  # 服务间调用所使用的名称

  # 数据源配置
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud_test?serverTimezone=Asia/Shanghai&useUnicode=true&useSSL=false&characterEncoding=utf8
    username: root
    password: 123456
    hikari:
      connection-timeout: 30000
      idle-timeout: 60000
      maximum-pool-size: 30
      minimum-idle: 10
  # redis配置
  redis:
    host: 127.0.0.1
    port: 6379
    password: 123456
    database: 0
    timeout: 1000
    jedis:
      pool:
        max-active: 100
        max-idle: 10
        max-wait: 100000
        min-idle: 10
  # kafka配置
  kafka:
#    bootstrap-servers: 172.0.0.1:9092
    bootstrap-servers: 47.92.221.53:9092
    # 生产者配置
    producer:
      # 发生错误时，消息重发的次数
      retries: 0
      # 当有多个消息需要（被）发送同一分区，生产者会把他们放在同一个批次中。
      # 该参数指定了一个批次可以使用的内存大小，按照字节数计算，默认为16K即16384
      batch-size: 16384
      # 生产者内存缓冲区的大小，默认为32M
      buffer-memory: 33554432
      # 键的序列化方式
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      # 值的序列化方式
      value-serializer: org.apache.kafka.common.serialization.StringSerializer

      # acks=0 : 表示produce请求立即返回，不需要等待leader的任何确认。这种方案有最高的吞吐率，但是不保证消息是否真的发送成功。
      # acks=1 : 表示leader副本必须应答此produce请求并写入消息到本地日志，之后produce请求被认为成功。如果此时leader副本应答请求之后挂掉了，消息会丢失。这种的方案，提供了不错的持久性保证和吞吐。
      # acks=-1 : 表示分区leader必须等待消息被成功写入到所有的ISR副本(同步副本)中才认为produce请求成功。这种方案提供最高的消息持久性保证，但是理论上吞吐率也是最差的。
      acks: 1

    # 消费者配置
    consumer:
      group-id: test
      # 自动提交的时间间隔,在spring boot 2.X 版本中这里采用的是值的类型为Duration 需要符合特定的格式，如1S,1M,2H,5D
      auto-commit-interval: 1s

      # 该属性指定了消费者在读取一个没有偏移量的分区或者偏移量无效的情况下该如何处理
      # latest(默认值): 在偏移量无效的情况下，消费者将从最新的记录开始读取数据（在消费者启动之后生成的记录）
      # earliest:      在偏移量无效的情况下，消费者将从起始位置读取分区的记录
      auto-offset-reset: earliest

      # 是否自动提交偏移量，默认值为true, 为了避免出现重复数据和数据丢失，可以设置为false,然后手动提交偏移量
      enable-auto-commit: false

      # 键的反序列化方式
      key-serializer: org.apache.kafka.common.serialization.StringDeserializer
      # 值的反序列化方式
      value-serializer: org.apache.kafka.common.serialization.StringDeserializer


    listener:
      # 在监听器容器中运行的线程数
      concurrency: 4
      # listener负责ack,每调用一次，就立即commit
      ack-mode: manual_immediate
      missing-topics-fatal: false

# mybatis的配置
mybatis:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl
  mapper-locations: classpath:mybatis/mapper/*.xml

logging:
  config: classpath:logback-spring.xml

#
#eureka:
#  instance:
#    hostname: http://127.0.0.1
#  client:
#    service-url:
#      defaultZone: http://${eureka.instance.hostname}:8761/eureka/
